//////////////////////////////////////////////////////////////////////////////
//
//  Presence of this DLL (detoured.dll) marks a process as detoured.
//
//  Microsoft Research Detours Package, Version 2.1.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include "detoured.h"
#include "detours.h"
#include "md5.h"
#include <TlHelp32.h>

#pragma comment(lib,"User32.lib")
static HMODULE s_hDll;

HMODULE WINAPI Detoured()
{
    return s_hDll;
}

#define  FEATURESIZE 512
//lpk.dll rva 4000处特征
unsigned char LpkFeature[FEATURESIZE] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x0A, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x65, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x80, 
	0x66, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x88, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 
	0xE4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x40, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 
	0xE4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 
	0x6B, 0x68, 0x71, 0x00, 0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
	0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xF0, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 
	0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 
	0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 
	0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xAB, 0x80, 0xCF, 0xCA, 0xEF, 0xE1, 0xA1, 0x99, 0xEF, 0xE1, 0xA1, 0x99, 
	0xEF, 0xE1, 0xA1, 0x99, 0x6C, 0xFD, 0xAF, 0x99, 0xEC, 0xE1, 0xA1, 0x99, 0x80, 0xFE, 0xAB, 0x99, 
	0xE4, 0xE1, 0xA1, 0x99, 0x80, 0xFE, 0xA5, 0x99, 0xED, 0xE1, 0xA1, 0x99, 0xD9, 0xC7, 0xAA, 0x99, 
	0xEE, 0xE1, 0xA1, 0x99, 0x2C, 0xEE, 0xFC, 0x99, 0xE6, 0xE1, 0xA1, 0x99, 0xEF, 0xE1, 0xA0, 0x99, 
	0x6D, 0xE1, 0xA1, 0x99, 0x07, 0xFE, 0xAA, 0x99, 0xE8, 0xE1, 0xA1, 0x99, 0x28, 0xE7, 0xA7, 0x99, 
	0xEE, 0xE1, 0xA1, 0x99, 0x52, 0x69, 0x63, 0x68, 0xEF, 0xE1, 0xA1, 0x99, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x4C, 0x01, 0x04, 0x00, 0x40, 0xED, 0x59, 0x4C, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x0F, 0x01, 0x0B, 0x01, 0x06, 0x00, 
	0x00, 0x54, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x60, 0x00, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
//子体 rva 1000 处内存特征
unsigned char SubFeature[FEATURESIZE] = {
	0x8B, 0x44, 0x24, 0x08, 0x8B, 0x4C, 0x24, 0x04, 0x6A, 0x00, 0x6A, 0x00, 0x50, 0x51, 0x6A, 0x00, 
		0x6A, 0x00, 0xFF, 0x15, 0x94, 0x70, 0x40, 0x00, 0xC2, 0x08, 0x00, 0x90, 0x90, 0x90, 0x90, 0x90, 
		0x8B, 0x44, 0x24, 0x04, 0x8D, 0x04, 0x40, 0x8D, 0x04, 0x80, 0x8D, 0x04, 0x80, 0x8D, 0x04, 0x80, 
		0x8D, 0x04, 0x80, 0xC1, 0xE0, 0x05, 0x40, 0x50, 0xFF, 0x15, 0x98, 0x70, 0x40, 0x00, 0xC7, 0x05, 
		0x20, 0x95, 0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 0x33, 0xC0, 0xC2, 0x04, 0x00, 0x90, 0x90, 0x90, 
		0xA1, 0x20, 0x95, 0x40, 0x00, 0x53, 0x8B, 0x5C, 0x24, 0x08, 0x56, 0x33, 0xF6, 0x57, 0x8B, 0xBB, 
		0x88, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x84, 0x36, 0x01, 0x00, 0x00, 0x89, 0x35, 0x20, 0x95, 
		0x40, 0x00, 0x8B, 0x83, 0x8C, 0x00, 0x00, 0x00, 0x48, 0x83, 0xF8, 0x20, 0x0F, 0x87, 0x01, 0x01, 
		0x00, 0x00, 0x33, 0xC9, 0x8A, 0x88, 0xE8, 0x11, 0x40, 0x00, 0xFF, 0x24, 0x8D, 0xA8, 0x11, 0x40, 
		0x00, 0xBE, 0xF0, 0x3C, 0x40, 0x00, 0xE9, 0xE8, 0x00, 0x00, 0x00, 0xBE, 0x20, 0x3E, 0x40, 0x00, 
		0xE9, 0xDE, 0x00, 0x00, 0x00, 0xBE, 0x50, 0x3F, 0x40, 0x00, 0xE9, 0xD4, 0x00, 0x00, 0x00, 0xBE, 
		0xD0, 0x3B, 0x40, 0x00, 0xE9, 0xCA, 0x00, 0x00, 0x00, 0xBE, 0xB0, 0x3F, 0x40, 0x00, 0xE9, 0xC0, 
		0x00, 0x00, 0x00, 0xBE, 0x40, 0x40, 0x40, 0x00, 0xE9, 0xB6, 0x00, 0x00, 0x00, 0x83, 0x3D, 0x04, 
		0x94, 0x40, 0x00, 0x01, 0x75, 0x0A, 0xBE, 0xE0, 0x48, 0x40, 0x00, 0xE9, 0xA3, 0x00, 0x00, 0x00, 
		0xBE, 0xC0, 0x3A, 0x40, 0x00, 0xE9, 0x99, 0x00, 0x00, 0x00, 0xA1, 0x04, 0x94, 0x40, 0x00, 0xBE, 
		0x70, 0x4F, 0x40, 0x00, 0x83, 0xF8, 0x01, 0x0F, 0x84, 0x83, 0x00, 0x00, 0x00, 0xBE, 0xC0, 0x3A, 
		0x40, 0x00, 0xEB, 0x7C, 0xA1, 0x04, 0x94, 0x40, 0x00, 0xBE, 0x60, 0x54, 0x40, 0x00, 0x83, 0xF8, 
		0x01, 0x74, 0x6D, 0xBE, 0xC0, 0x3A, 0x40, 0x00, 0xEB, 0x66, 0xA1, 0x04, 0x94, 0x40, 0x00, 0xBE, 
		0x00, 0x4D, 0x40, 0x00, 0x83, 0xF8, 0x01, 0x74, 0x57, 0xBE, 0xC0, 0x3A, 0x40, 0x00, 0xEB, 0x50, 
		0xA1, 0x04, 0x94, 0x40, 0x00, 0xBE, 0xE0, 0x48, 0x40, 0x00, 0x83, 0xF8, 0x01, 0x74, 0x41, 0xEB, 
		0x3A, 0xA1, 0x04, 0x94, 0x40, 0x00, 0xBE, 0x70, 0x4F, 0x40, 0x00, 0x83, 0xF8, 0x01, 0x74, 0x30, 
		0xEB, 0x29, 0x8B, 0x15, 0x04, 0x94, 0x40, 0x00, 0xBE, 0xF0, 0x3C, 0x40, 0x00, 0x4A, 0xF7, 0xDA, 
		0x1B, 0xD2, 0x83, 0xE2, 0xD4, 0x83, 0xC2, 0x40, 0x03, 0xFA, 0xEB, 0x17, 0xA1, 0x04, 0x94, 0x40, 
		0x00, 0xBE, 0x00, 0x4D, 0x40, 0x00, 0x83, 0xF8, 0x01, 0x74, 0x05, 0xBE, 0xF0, 0x3C, 0x40, 0x00, 
		0x83, 0xC7, 0x14, 0x85, 0xFF, 0x76, 0x0A, 0x53, 0x56, 0xE8, 0x72, 0xFE, 0xFF, 0xFF, 0x4F, 0x75, 
		0xF6, 0x8B, 0x83, 0x84, 0x00, 0x00, 0x00, 0x50, 0x68, 0x20, 0x10, 0x40, 0x00, 0xE8, 0x5E, 0xFE, 
		0xFF, 0xFF, 0x5F, 0x5E, 0x5B, 0xC3, 0x8B, 0xFF, 0x91, 0x10, 0x40, 0x00, 0xE0, 0x10, 0x40, 0x00, 
		0x9B, 0x10, 0x40, 0x00, 0xA5, 0x10, 0x40, 0x00, 0xCD, 0x10, 0x40, 0x00, 0xEA, 0x10, 0x40, 0x00, 
		0x04, 0x11, 0x40, 0x00, 0x30, 0x11, 0x40, 0x00, 0x41, 0x11, 0x40, 0x00, 0x52, 0x11, 0x40, 0x00, 
		0x1A, 0x11, 0x40, 0x00, 0x6C, 0x11, 0x40, 0x00, 0xAF, 0x10, 0x40, 0x00, 0xB9, 0x10, 0x40, 0x00, 
		0xC3, 0x10, 0x40, 0x00, 0x83, 0x11, 0x40, 0x00, 0x00, 0x01, 0x02, 0x03, 0x0F, 0x0F, 0x0F, 0x0F, 
		0x04, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0F, 0x0F, 0x0A, 0x0B
};

//内存查找所有模块特征
DWORD __stdcall scanlpk(LPVOID lpArg)	
{
	while(TRUE)
	{
		HANDLE        hModuleSnap = NULL; 
		MODULEENTRY32 me          = {0}; 
		char PathNameBuf[MAX_PATH] ;
		
		// Take a snapshot of all modules in the specified process. 
		hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, 0); 
		if (hModuleSnap == INVALID_HANDLE_VALUE) 
			continue; 
		
		// Fill the size of the structure before using it. 
		me.dwSize = sizeof(MODULEENTRY32); 
		
		if (Module32First(hModuleSnap, &me)) 
		{ 
			do 
			{ 
				RtlZeroMemory(PathNameBuf, MAX_PATH);
				wsprintf(PathNameBuf, "进程ID: %d \r\n查找模块:%s %08X = %08X \r\n",
					me.th32ProcessID,
					me.szExePath,
					me.modBaseAddr,
					scanlpk);
				
				OutputDebugString(PathNameBuf);
				
				if (0 == IsBadReadPtr(me.modBaseAddr+0x4000, MAX_PATH))
				{
					//判断是否为母体或子体 //LpkFeature SubFeature
					_asm	//调试用
					{
						mov eax, eax
							mov eax, eax
					}
					if (0 == memcmp(me.modBaseAddr+0x4000, LpkFeature, MAX_PATH) ||
						0 == memcmp(me.modBaseAddr+0x1000, SubFeature, MAX_PATH))
					{
						RtlZeroMemory(PathNameBuf, MAX_PATH);
						wsprintf(PathNameBuf, "检查到 进程ID: %d \r\n病毒模块:%s %08X\r\n 是否强投制卸载该模,导致进程关闭\r\nYes:关闭 NO:放行",
							me.th32ProcessID,
							me.szExePath);
						if (IDYES == MessageBox(NULL, PathNameBuf, "内存查杀", MB_YESNO|MB_ICONWARNING))
						{
							TerminateProcess((HMODULE)-1, 0);
						}
					}
				}
				
			} 
			while (Module32Next(hModuleSnap, &me)); 
		}
		
		CloseHandle (hModuleSnap); 

		Sleep(2000);
	}
    
    return (1); 


}

//指向原始(老)的函数地址,声明定义自己在这里改
BOOL (WINAPI* lpOlDFun)(IN LPCWSTR lpExistingFileName,
						IN LPCWSTR lpNewFileName,
						IN BOOL bFailIfExists) = CopyFileW;

//新的
BOOL WINAPI lpNewFun(IN LPCWSTR lpExistingFileName,
					 IN LPCWSTR lpNewFileName,
					 IN BOOL bFailIfExists)
{

	HANDLE hFile; 
	char FileBuf[1000];
	char* lpMD5Value = NULL;
	
	RtlZeroMemory(FileBuf, 1000);
	
	hFile = CreateFileW(lpExistingFileName,      
		GENERIC_READ,              // open for reading 
		FILE_SHARE_READ,           // share for reading 
		NULL,                      // no security 
		OPEN_EXISTING,             // existing file only 
		FILE_ATTRIBUTE_NORMAL,     // normal file 
		NULL);                     // no attr. template 
	
	DWORD dwRet = SetFilePointer(hFile, 0x400, 0, FILE_BEGIN);
	BOOL IsOk = ReadFile(hFile, FileBuf, 1000, &dwRet, NULL);
	CloseHandle(hFile);

	if (FALSE == IsOk) //3个函数作最后一次检查 
	{
		return lpOlDFun(lpExistingFileName,lpNewFileName,bFailIfExists);
	}
	
	
	//母体文件0400处开始1000字节md5值为: 8b4f20968d1947e8d7c7c62d52c6a373
	//判断是否为母体
	if (!MD5Check("8b4f20968d1947e8d7c7c62d52c6a373", FileBuf, 1000) &&
		!MD5Check("f540fd4de29072b9fd021c8b377e5989", FileBuf, 1000))
	{
		return lpOlDFun(lpExistingFileName,lpNewFileName,bFailIfExists);;
	}

	WCHAR* lpcmd = ::GetCommandLineW();
	WCHAR Buf[500] ={0};
	
	wsprintfW(Buf,
			L"发现作案进程信息:\r\nID:%d\r\nnamme:%s\r\n源:%s\r\n目的:%s\r\n YES: 强制Y束进程并删除服务信息. NO: 放行!\r\n",
			GetCurrentProcessId(),
			lpcmd,
			lpExistingFileName,
			lpNewFileName);
	
	static BOOL bShowMsg = FALSE;	//还没弹信息框
	
	while(bShowMsg)
	{
		Sleep(200);
	}

	bShowMsg = TRUE;
	if (IDYES == MessageBoxW(NULL, Buf, L"防疫监控警告", MB_YESNO|MB_ICONWARNING))
	{	
		TerminateProcess((HANDLE)-1, 0);
	}
	bShowMsg = FALSE;

	//切记不能调用原始函数api,否则死了
	return lpOlDFun(lpExistingFileName,lpNewFileName,bFailIfExists);
}



BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    (void)reserved;
	static HANDLE hScanLpkTrhead = NULL;

    if (dwReason == DLL_PROCESS_ATTACH) {
        s_hDll = hinst;
        DisableThreadLibraryCalls(hinst);
		
		DetourRestoreAfterWith();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourAttach(&(PVOID&)lpOlDFun, lpNewFun);
		DetourTransactionCommit();
				
		if (NULL == hScanLpkTrhead)
		{
			hScanLpkTrhead = CreateThread(NULL, NULL, scanlpk, NULL, NULL, NULL);
			OutputDebugString("内存查杀线程启动成功!\r\n");
		}
		else
		{
			OutputDebugString("内存查杀线程已经启动!\r\n");
		}
    }
	else if (DLL_PROCESS_DETACH == dwReason)
	{
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourDetach(&(PVOID&)lpOlDFun, lpNewFun);
		DetourTransactionCommit();

		if (NULL != hScanLpkTrhead)
		{
			TerminateThread(hScanLpkTrhead, 0);
			hScanLpkTrhead = NULL;
		}

	}
    return TRUE;
}

//
///////////////////////////////////////////////////////////////// End of File.
